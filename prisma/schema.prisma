// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum Role {
  MAIN_ADMIN
  MANAGER
  AGENT
}

enum BlockType {
  WORKING
  REST
  EXTRA_TIME
}

enum EventType {
  SEED
  CALLBACK
  LEAD
  SALE
}

model User {
  id            Int      @id @default(autoincrement())
  email         String   @unique
  passwordHash  String   // Store hashed passwords only
  role          Role     @default(AGENT)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations to your existing entities
  companyId     Int
  company       Company  @relation(fields: [companyId], references: [id])
  
  // Optional links depending on the role
  managerProfile Manager? @relation(fields: [managerId], references: [id])
  managerId      Int?     @unique
  
  agentProfile   Agent?   @relation(fields: [agentId], references: [id])
  agentId        Int?     @unique

  // Constraint: One MAIN_ADMIN per company
  // This is enforced via a unique partial index in the DB (see note below)
}

model Company {
  id           Int           @id @default(autoincrement())
  name         String
  createdAt    DateTime      @default(now())
  managers     Manager[]
  teams        Team[]
  agents       Agent[]
  blockSchemas BlockSchema[]
  users        User[]
}

model Manager {
  id        Int     @id @default(autoincrement())
  name      String
  email     String  @unique
  company   Company @relation(fields: [companyId], references: [id]) // companyId is the foreign key, and it is compared with the `id` field of the other table
  companyId Int
  teams     Team[]
  user      User?
}

model Team {
  id           Int            @id @default(autoincrement())
  name         String
  company      Company        @relation(fields: [companyId], references: [id])
  companyId    Int
  manager      Manager[] // many to many relation -> a manager have teams, a team have managers 
  agents       Agent[]
  calls        Call[]
  assignments  ScheduledDay[]
}

model Agent {
  id          Int            @id @default(autoincrement())
  name        String
  team        Team           @relation(fields: [teamId], references: [id])
  teamId      Int            
  company     Company        @relation(fields: [companyId], references: [id])
  companyId   Int
  calls       Call[]
  feelings    AgentState[]
  assignments ScheduledDay[]
  events      FunnelEvent[]
  user        User?
}

model Callee {
  id            Int    @id @default(autoincrement())
  phoneNumber   String @unique
  totalAttempts Int    @default(0)
  calls         Call[]
}

// --- TEMPORAL LOGIC (BLOCKS) ---

model BlockSchema {
  id                Int                @id @default(autoincrement())
  name              String
  company           Company            @relation(fields: [companyId], references: [id])
  companyId         Int
  isHotModification Boolean            @default(false)
  originalSchemaId  Int?
  originalSchema    BlockSchema?       @relation("SchemaHistory", fields: [originalSchemaId], references: [id])
  modifiedSchemas   BlockSchema[]      @relation("SchemaHistory")
  definitions       SchemaDefinition[]
  assignments       ScheduledDay[]
}

model SchemaDefinition {
  id          Int       @id @default(autoincrement())
  schema      BlockSchema @relation(fields: [schemaId], references: [id])
  schemaId    Int
  startTime   DateTime  // Absolute time for that specific day
  endTime     DateTime
  blockType   BlockType @default(WORKING)
  calls       Call[]
}

model ScheduledDay {
  id        Int         @id @default(autoincrement())
  date      DateTime    @db.Date
  agent     Agent?      @relation(fields: [agentId], references: [id])
  agentId   Int?
  team      Team?       @relation(fields: [teamId], references: [id])
  teamId    Int?
  schema    BlockSchema @relation(fields: [schemaId], references: [id])
  schemaId  Int
}

// --- PERFORMANCE DATA ---

model Call {
  id                Int              @id @default(autoincrement())
  agent             Agent            @relation(fields: [agentId], references: [id])
  agentId           Int
  team              Team             @relation(fields: [teamId], references: [id])
  teamId            Int
  callee            Callee           @relation(fields: [calleeId], references: [id])
  calleeId          Int
  blockDefinition   SchemaDefinition? @relation(fields: [blockDefinitionId], references: [id])
  blockDefinitionId Int?             // Null if "Extra Time"
  
  startAt           DateTime         @default(now())
  endAt             DateTime?
  durationSeconds   Int              @default(0)
  isEffective       Boolean          @default(false)
  
  events            FunnelEvent[]
}

model FunnelEvent {
  id        Int       @id @default(autoincrement())
  type      EventType
  timestamp DateTime  @default(now())
  call      Call      @relation(fields: [callId], references: [id])
  callId    Int
  agent     Agent     @relation(fields: [agentId], references: [id])
  agentId   Int
}

model AgentState {
  id              Int      @id @default(autoincrement())
  agent           Agent    @relation(fields: [agentId], references: [id])
  agentId         Int
  timestamp       DateTime @default(now())
  energyScore     Int      // 1-10
  focusScore      Int      // 1-10
  motivationScore Int      // 1-10
}

/*
Looking at this prisma schema:
```
```

Let me know if it is possible to fetch the next information:

I'm gonna need to fetch data as follows:
- Per agent, per time (from-to values used to select a time gap)
- Per agent, per block (from-to values used to search for in-range blocks)
- Per selected agents, per time (from-to values used to select a time gap)
- Per selected agents, per block (from-to values used to search for in-range blocks)
- Per team, per time (from-to values used to select a time gap)
- Per team, per block (from-to values used to search for in-range blocks)
- ALL AGENTS DATA, per time (from-to values used to select a time gap)
- ALL AGENTS DATA, per block (from-to values used to search for in-range blocks)

I would need to fetch the next values (individually, then I prepare the views):
• Total effective talk time
• Number of logged calls
• Number of calls longer than 5 minutes
• Average call duration
• Calls per hour
• Active time vs idle time (time in call vs time of)
• Long call ratio
* total Seeds
• total Callbacks
• total Leads
• total Sales
* energy
* focus
* motivation

When I say "fetch" I just want to now if it is possible to fetch each individual point, because that means I an create compound queires that give me specific views. 
Also, for each point, give me a path to access to each point, for example: "Per agent, per time calls per hour: agentId->calls inside from-to -> divide results in hours and calculate counting the n. of calls perfomed" 
If there is one point I can not access, let me know, but I think is possible access to all. 
*/