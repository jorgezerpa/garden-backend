// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init



// IMPORTANT
// - Leaddesk API does not allows ut to fetch a list of agents, so, We will just store it once a call is performed. MAYBE from LD dashboard a agents list can be downloaded and uploaded here?

/*
MAIN FLOW
- A company manager gets into our dashboard 
- He registers as a manager, providing email, password. 
- Is redirected to the dashboard in the page "Connections"
- It is required to input the leaddesk auth token 
- ?? enters the agents -> autofetching(leaddesk api does not provide a way to fetch agents), manual input or upload csv or excel file
---
- An agent performs a call
- Leaddesk webhook calls the api endpoint "manage_webhook"
- "manage_webhook" will read the parameter "last_call_id"
- Call the leaddesk endpoint "https://api.leaddesk.com?auth=X&mod=call&cmd=get&call_ref_id=last_call_id"
- The endpoint returns the next data:
  {
    "id": "4999",
    "agent_id": "11",
    "agent_username": "teuvotest",
    "talk_time": "45",
    "talk_start": "2016-01-01 12:13:14",
    "talk_end": "2016-02-02 14:12:10",
    "number": "+358123123",
    "campaign": "14",
    "campaign_name": "test campaign",
    "record_file": "test_recording.wav.mp3",
    "created_at": "2016-01-01 12:13:10",
    "customer_id": "21",
    "comment": "test comment",
    "agent_group_id": "13",
    "agent_group_name": "test group",
    "call_ending_reason": "15",
    "call_ending_reason_name": "test reason",
    "handling_stop": "2016-02-02 14:20:30",
    "direction": "out",
    "call_type": "1",
    "contact_id": "1",
    "call_type_name": "semi",
    "order_ids": [
      1,
      3
    ]
  } 

- WE use that info to register in our database:
  - 

*/



generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum Role {
  MAIN_ADMIN
  MANAGER
  AGENT
}

enum BlockType {
  WORKING
  REST
  EXTRA_TIME
}

enum SchemaType {
  DAILY
  WEEKLY
  MONTHLY
}

enum EventType {
  SEED
  CALLBACK
  LEAD
  SALE
}

model User {
  id            Int      @id @default(autoincrement())
  email         String   @unique
  passwordHash  String   // Store hashed passwords only
  role          Role     @default(AGENT)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations to your existing entities
  companyId     Int
  company       Company  @relation(fields: [companyId], references: [id])
  
  // Optional links depending on the role
  managerProfile Manager? @relation(fields: [managerId], references: [id])
  managerId      Int?     @unique
  
  agentProfile   Agent?   @relation(fields: [agentId], references: [id])
  agentId        Int?     @unique

  // Constraint: One MAIN_ADMIN per company
  // This is enforced via a unique partial index in the DB (see note below)
}

model Company {
  id            Int           @id @default(autoincrement())
  name          String
  createdAt     DateTime      @default(now())
  managers      Manager[]
  agents        Agent[]
  calls         Call[]
  TimeSchemas   Schema[]
  users         User[]
  temporalGoals TemporalGoals[]
  apiKey        APIKeysAuth?
}

// 1-to-1 company-key (used to authenticate webhook call origin)
// @dev@IMPORTANT probably not the most secure approach, research how is this managed in secure apps 
model APIKeysAuth {
  id            Int      @id @default(autoincrement())
  
  // Use UUIDs for the keys. 
  // 'public' is a reserved keyword in some DBs, 'publicKey' is safer.
  publicKey     String   @unique // uuid prefixed with a specific string exp: "prefix-uuid" 
  secretKeyHash String   @unique // hashed secret 
  // Link to company and ensure 1-to-1
  company       Company  @relation(fields: [companyId], references: [id])
  companyId     Int      @unique 

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Manager {
  id        Int     @id @default(autoincrement())
  name      String
  email     String  @unique
  company   Company @relation(fields: [companyId], references: [id]) // companyId is the foreign key, and it is compared with the `id` field of the other table
  companyId Int
  user      User?
  temporalGoals TemporalGoals[]
  schemas   Schema[]
}

model Agent {
  id          Int            @id @default(autoincrement())
  name        String
  company     Company        @relation(fields: [companyId], references: [id])
  companyId   Int
  calls       Call[]
  feelings    AgentState[]
  events      FunnelEvent[]
  user        User?
}

model Callee {
  id            Int    @id @default(autoincrement())
  phoneNumber   String @unique
  totalAttempts Int    @default(0)
  calls         Call[]
}

// --- BLOCKS MASKS ---
// Managers create time schedules by block, so the can filter the call querying by such blocks 

model Schema {
  id                Int                @id @default(autoincrement())
  name              String
  type              SchemaType         @default(DAILY)
  company           Company            @relation(fields: [companyId], references: [id])
  companyId         Int
  creator           Manager            @relation(fields: [creatorId], references: [id])
  creatorId         Int
  schemaDays        SchemaDay[] // @dev how is this order handled? should I add an "index" column?
}

// a 7 day schema has 7 Schema days, a month schema have 30-31 shcema days, and so on
// so, no matter the schema type, it always will be divided by blocks (in hours) by days by type(day,week,month)
model SchemaDay {
  id          Int       @id @default(autoincrement())
  schema      Schema @relation(fields: [schemaId], references: [id])
  schemaId    Int
  // --------
  dayIndex    Int // MAX: 0 for DAILY, 6 for WEEKLY, 30-31 for MONTHLY  
  blocks      SchemaBlock[]
  @@unique([schemaId, dayIndex]) // avoids repetition of day index per schema (i.e 2 days 1)
}

model SchemaBlock {
  id                        Int         @id @default(autoincrement())
  startMinutesFromMidnight  Int
  endMinutesFromMidnight    Int
  schemaDay                 SchemaDay   @relation(fields: [schemaDayId], references: [id])
  schemaDayId               Int
  blockType                 BlockType   @default(WORKING)
  name                      String?     // (e.g., "Morning Blitz", "Afternoon Follow-ups")
}


// --- PERFORMANCE DATA ---

model Call {
  id                Int              @id @default(autoincrement())
  leadDeskId        String?             // Not unique because can variate per company. Also, this is temporary, will be better to create another table so we can handle multiple services aside leaddesk 
  agent             Agent            @relation(fields: [agentId], references: [id])
  agentId           Int
  callee            Callee           @relation(fields: [calleeId], references: [id])
  calleeId          Int
  company           Company           @relation(fields: [companyId], references: [id])
  companyId         Int
  startAt           DateTime         @default(now())
  endAt             DateTime?
  durationSeconds   Int              @default(0)
  // isEffective       Boolean          @default(false)
  
  events            FunnelEvent[]
}

model FunnelEvent {
  id        Int       @id @default(autoincrement())
  type      EventType
  timestamp DateTime  @default(now())
  call      Call      @relation(fields: [callId], references: [id])
  callId    Int
  agent     Agent     @relation(fields: [agentId], references: [id])
  agentId   Int
}

model AgentState {
  id              Int      @id @default(autoincrement())
  agent           Agent    @relation(fields: [agentId], references: [id])
  agentId         Int
  timestamp       DateTime @default(now())
  energyScore     Int      // 1-10
  focusScore      Int      // 1-10
  motivationScore Int      // 1-10
}

model TemporalGoals {
  id                Int      @id @default(autoincrement())
  
  // Time Range
  // @TODO instead of hardcode this, use this as a template, and create another table for assigments which is the one will use the agents dashboard to render the goals 
  startTime         DateTime
  endTime           DateTime

  
  // Productivity Targets
  talkTimeMinutes   Int      @default(0)
  seeds             Int      @default(0)
  callbacks         Int      @default(0)
  leads             Int      @default(0)
  sales             Int      @default(0)
  numberOfCalls     Int      @default(0)
  numberOfLongCalls Int      @default(0)
  // Relations
  company           Company  @relation(fields: [companyId], references: [id])
  companyId         Int
  creator           Manager  @relation(fields: [creatorId], references: [id])
  creatorId         Int
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

/*
Looking at this prisma schema:
```
```

Let me know if it is possible to fetch the next information:

I'm gonna need to fetch data as follows:
- Per agent, per time (from-to values used to select a time gap)
- Per agent, per block (from-to values used to search for in-range blocks)
- Per selected agents, per time (from-to values used to select a time gap)
- Per selected agents, per block (from-to values used to search for in-range blocks)
- Per team, per time (from-to values used to select a time gap)
- Per team, per block (from-to values used to search for in-range blocks)
- ALL AGENTS DATA, per time (from-to values used to select a time gap)
- ALL AGENTS DATA, per block (from-to values used to search for in-range blocks)

I would need to fetch the next values (individually, then I prepare the views):
• Total effective talk time
• Number of logged calls
• Number of calls longer than 5 minutes
• Average call duration
• Calls per hour
• Active time vs idle time (time in call vs time of)
• Long call ratio
* total Seeds
• total Callbacks
• total Leads
• total Sales
* energy
* focus
* motivation

When I say "fetch" I just want to now if it is possible to fetch each individual point, because that means I an create compound queires that give me specific views. 
Also, for each point, give me a path to access to each point, for example: "Per agent, per time calls per hour: agentId->calls inside from-to -> divide results in hours and calculate counting the n. of calls perfomed" 
If there is one point I can not access, let me know, but I think is possible access to all. 
*/